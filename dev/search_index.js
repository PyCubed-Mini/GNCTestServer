var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"CurrentModule = SatellitePlayground","category":"page"},{"location":"api/#SatellitePlayground.jl-API","page":"API","title":"SatellitePlayground.jl API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The API all revolves around the simulate function which has two modes of running:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Software in the loop: A separate program pretends to be a satellite, and the simulator and program communicate sensor/control data between them.   This is useful for testing your true satellite software to make sure the guidance, navigation, and controll code still works despite all the other things it is doing.\nControl function: A function is passed a measurement (by default the state, parameters, and time in body frame) and returns the magnetorquer control input.   This is useful for directly testing attitude control schemes.","category":"page"},{"location":"api/","page":"API","title":"API","text":"simulate","category":"page"},{"location":"api/#SatellitePlayground.simulate","page":"API","title":"SatellitePlayground.simulate","text":"simulate(control::Function)\nsimulate(launch::Cmd)\nsimluate(control::Function, log_init=default_log_init, log_step=default_log_step,\nterminal_condition=default_terminate, max_iterations=1000,\ndt=0.5, initial_condition=nothing, measure=default_measure)\n\nRuns a simulation from a random initial condition (or from initialcondition) if given. The simulation runs for maxiterations steps.\n\nThe control input to the magnetorquer coils at each time step is set either by the given control  function, or by the GNCTestClient launched by the launch command.\n\nBy default the controller recieves the (state, parameters, time) in the body frame. But this can be changed by setting the measurement function measure.\n\nThe simulation logs the angular velocity and its mangitude by default. However, by setting the log_* functions one can log arbitrary data.\n\n\n\n\n\n","category":"function"},{"location":"api/#State","page":"API","title":"State","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"RBState","category":"page"},{"location":"api/#SatellitePlayground.RBState","page":"API","title":"SatellitePlayground.RBState","text":"Based on: https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/master/src/rbstate.jl\n\nRBState{T} <: StaticVector{13,T}\n\nRepresents the state of a rigid body in 3D space, consisting of position, orientation, linear     velocity and angular velocity, respresented as a vector stacked in that order, with     the rotation represented as the 4 elements of a unit quaternion.\n\nImplements the StaticArrays interface so can be treated as an SVector with additional     methods.\n\nConstructors\n\nRBState{T}(r, v, q, ω)\nRBState{T}(x)\nRBState(r, v, q, ω)\nRBState(x)\n\nwhere r, v, and ω are three-dimensional vectors, q is either a Rotation or a     four-dimenional vector representing the parameters of unit quaternion, and x is a     13-dimensional vector (or tuple),\n\nConverting to a State Vector\n\nAn RBState can be converted to a state vector for a RigidBody using     RBState(model::RBstate, x, [renorm=false])\n\n\n\n\n\n","category":"type"},{"location":"api/#Useful-Helper-Functions","page":"API","title":"Useful Helper Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"word_to_body\ninitialize_orbit","category":"page"},{"location":"api/#SatellitePlayground.initialize_orbit","page":"API","title":"SatellitePlayground.initialize_orbit","text":"initialize_orbit(; r=nothing, v=nothing, a=nothing, q=nothing, ω=nothing, Rₑ=6378.137e3, μ=3.9860044188e14)\n\nInitializes a random, viable orbit given a few different terms, usually  a position 'r' in Cartesian coordinates. Initial velocity may be specified, but  if specified it will not necessarily result in a stable orbit. \n\nThe initial starting position, velocity, semi-major axis, orientation, and angular  velocity may be either specified or determined randomly. \n\nArguments:\n\nr:  (Optional) Height above ground that the satellite will start its orbit at    |  Scalar \nv:  (Optional) Magnitude of initial velocity                                     |  Scalar \na:  (Optional) Semi-major axis                                                   |  Scalar \nq:  (Optional) Initial attitude, as a unit quaternion                            |  [4,]\nω:  (Optional) Initial angular velocity                                          |  [3,]\n\nReturns:\n\nx:  Initial state, as (r, v, q, ω)                                               |  State\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"","text":"","category":"section"},{"location":"#SatellitePlayground.jl","page":"Home","title":"SatellitePlayground.jl","text":"","category":"section"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Satelite dynamics, with magnetorquers\nSoftware in the loop testing via the GNCTestClient\nExplicit control functions","category":"page"},{"location":"#Quick-Start-(Detumbling-Simulation-Example)","page":"Home","title":"Quick Start (Detumbling Simulation Example)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In this example we'll write a simple detumbling test enviorment. First install the SatellitePlayground package, for ease of use, we'll define SP=SatellitePlayground","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SatellitePlayground\nSP = SatellitePlayground","category":"page"},{"location":"","page":"Home","title":"Home","text":"To run a simulation with default parameters, one must supply a control function. To start we'll make a no_control function. By default measurement is a tuple of (state, parameters).","category":"page"},{"location":"","page":"Home","title":"Home","text":"function no_control(measurement)\n    return zero(SP.Control)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"To run this simulation simply run","category":"page"},{"location":"","page":"Home","title":"Home","text":"(hist, time) = SP.simulate(no_control)","category":"page"},{"location":"","page":"Home","title":"Home","text":"By default this simulation will log the angular velocity and its magnitude, and the coresponding times. Hist will contain a vector of vectors containing [angular_velocity; norm(angular_velocity)] To plot this data you can run the following, the vec2mat is required to make Plots happy.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\nhist = SP.vec_to_mat(hist)\nplot(time, hist, title=\"Angular Velocity\", xlabel=\"Time (s)\", ylabel=\"Angular Velocity (rad/s)\", labels=[\"ω1\" \"ω2\" \"ω3\" \"||ω||\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"By default this simulation will run for 1000 iterations. However, you change change this by setting max_iterations, or terminal_condition.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In our case we will set increase the number of maximum iterations to 10,000, and make the simulation terminate once the angular velocity drops below 0.01 radians.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LinearAlgebra # for norm\nfunction terminate(state, params, time, i)\n    return norm(state.angular_velocity) < 0.01\nend\n(hist, time) = SP.simulate(no_control, max_iterations=10_000, terminal_condition=terminate)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We will now use the b-cross controller to detumble the satellite.","category":"page"},{"location":"","page":"Home","title":"Home","text":"function bcross_controller(measurement)\n    (ω, b) = measurement\n\n    b̂ = b / norm(b)\n    k = 7e-4\n    M = -k * (I(3) - b̂ * b̂') * ω\n    m = 1 / (dot(b, b)) * cross(b, M)\n    return SP.Control(\n        m\n    )\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"To demonstrate measurement functions (which are intended for adding error models), we will write a measurement function that returns a measurement of the form (angular_velocity, b), rather than the default (state, parameters).","category":"page"},{"location":"","page":"Home","title":"Home","text":"function measure(state, params, time)\n    return (state.angular_velocity, params.b)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, we will run the simulation with the new controller and measurement function.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(hist, time) = SP.simulate(bcross_controller, max_iterations=10_000, terminal_condition=terminate, measure=measure)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This simulation will run for 10,000 iterations, or until the angular velocity drops below 0.01 radians. A few examples of the results are shown below. (Image: Angular Velocity over time with a detumbling controller) (Image: Angular Velocity over time with a detumbling controller) (Image: Angular Velocity over time with a detumbling controller)","category":"page"}]
}
